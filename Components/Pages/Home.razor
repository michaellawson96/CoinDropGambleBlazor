@page "/"
@using System.ComponentModel
@using CoinDropGamble.Models.Enums
@using CoinDropGamble.Helpers
@rendermode InteractiveServer

<PageTitle>Coin Drop Gamble</PageTitle>

@if (!_isGameStarted)
{
    <div class="d-flex flex-column justify-content-center align-items-center vh-100 background">
        <div class="card text-center text-white bg-dark shadow-lg">
            <div class="card-body">
                <h1 class="card-title">Coin Drop Gamble</h1>
                <p class="card-text">
                    Enter a high-stakes game where every coin counts. 
                    Manage your chances, outsmart your opponent, and 
                    survive the gamble.
                </p>
                <button class="btn btn-warning btn-lg" @onclick="StartGameButtonPressed">Start Game</button>
            </div>
        </div>
    </div>
}
else
{
    <div class="flex flex-column justify-content-center align-items-center vh-25 py-2 background">
    <div class="row g-4">
        <!-- Capacity Section on top of image section -->
        <div class="col-lg-4 d-flex flex-column">
            <div class="card text-center text-white bg-dark shadow-lg section-card flex-fill">
                <div class="card-body capacity-section">
                    <h3 class="card-title">BETWEEN @(_piggyBankCapacity-_lowerDisparity) AND @(_piggyBankCapacity + _higherDisparity)</h3>
                </div>
            </div>
            <div class="card text-center text-white bg-dark shadow-lg section-card flex-fill image-section">
                <img src="@_imagePath" class="card bg-dark"/>
            </div>
        </div>

        <!-- Description Section -->
        <div class="col-lg-8 d-flex flex-column">
            <div class="card text-center text-white bg-dark shadow-lg section-card flex-fill">
                <div class="card-body description-section">
                    @if(_dialogList.Any()){
                        <p class="card-text">@_dialogList[0].line1</p>
                        <p class="card-text"> @_dialogList[0].line2</p>
                        <button class="btn btn-primary flashing-button" @onclick="ProgressDialogStream">Continue</button>
                    }
                    else if (_dialog.line1 is not null)
                    {
                        <p class="card-text">@_dialog.line1</p>
                        <p class="card-text"> @_dialog.line2</p>
                    }
                    
                </div>
            </div>
        </div>
    </div>
</div>

<div class="flex flex-column justify-content-center align-items-center vh-50 py-2 background">
    <div class="row g-4">
        <!-- Action Section -->
        <div class="col-6 d-flex flex-column">
            <div class="card text-center text-white bg-dark shadow-lg section-card flex-fill">
                <div class="card-body action-section">
                    <div class="row">
                        <!-- Drop Coin Action -->
                        <button 
                            class="btn btn-primary btn-lg col-12 my-1" 
                            disabled="@(_isPlayerCoinDisabled || _isPlayerControlsDisabled || (_playerPlayedCoinsCount == MAX_COINS_PLAYABLE))" 
                            @onclick="PlayerDropCoinAction">
                            @* Render the coins *@
                            @for (int i = 0; i < MAX_COINS_PLAYABLE; i++)
                            {
                                <i class="bi @(i < _playerPlayedCoinsCount ? "bi-dash-circle-dotted text-secondary" : "bi-coin text-warning") me-1"></i>
                            }
                        </button>
                        <!-- Shake Action -->
                        <button class="btn btn-success btn-lg col-12 my-1 " disabled="@(_isPlayerShakeDisabled || _hasPlayerShakenThisRound || _isPlayerControlsDisabled)" @onclick="PlayerShakeAction">Shake</button>
                        <!-- Special Action -->
                        <button class="btn btn-warning btn-lg col-12  my-1 " disabled="@(_isPlayerSpecialDisabled || !_playerSpecialCoins.Any() || _isPlayerControlsDisabled)" @onclick="SpecialAction">Special</button>
                        <!-- End Turn Action -->
                        <button class="btn btn-danger btn-lg col-12  my-1 " disabled="@(_isPlayerEndTurnDisabled || !_hasPlayerActedThisTurn || _isPlayerControlsDisabled )" @onclick="EndTurnAction">End Turn</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Status Section -->
        <div class="col-6 d-flex flex-column">
            <div class="card text-center text-white bg-dark shadow-lg section-card flex-fill">
                <div class="card-body status-section">
                    
                    <p class="card-text">
                        PLAYER
                        @if(_isPlayersTurn)
                        {
                            <span class="badge rounded-pill bg-success">Your Turn</span>
                        }
                    </p>
                    <p class="card-text">
                        @for (int i = 0; i < _currentGameMaxHealth; i++)
                        {
                            if (i < _playerHealthCount)
                            {
                                <i class="bi bi-heart-fill text-danger"></i> <!-- Filled heart for health left -->
                            }
                            else
                            {
                                <i class="bi bi-heart text-danger"></i> <!-- Empty heart for health lost -->
                            }
                        }

                        &nbsp;$ @_playerPocketMoneyCount
                    </p>
                    <p class="card-text">Games Won: @_gamesWon</p>
                    <hr>
                    <p class="card-text">
                        OPPONENT
                        @if(_isOpponentsTurn)
                        {
                            <span class="badge rounded-pill bg-success">Your Turn</span>
                        }
                    </p>
                    <p class="card-text">
                        @for (int i = 0; i < _currentGameMaxHealth; i++)
                        {
                            if (i < _opponentHealthCount)
                            {
                                <i class="bi bi-heart-fill text-danger"></i> <!-- Filled heart for health left -->
                            }
                            else
                            {
                                <i class="bi bi-heart text-danger"></i> <!-- Empty heart for health lost -->
                            }
                        }

                        &nbsp;$ @_opponentPocketMoneyCount
                    </p>
                    
                </div>
            </div>
        </div>
    </div>
</div>


}

@code {
    private const int MAX_COINS_PLAYABLE = 3;
    private const string COFFIN_IMAGE_PATH = "images/coffin.jpeg";
    private const string COIN_BRIEFCASE_IMAGE_PATH = "images/coin-briefcase.jpeg";
    private const string PIGGY_BANK_IMAGE_PATH = "images/piggy-bank-towards-viewer.jpeg";
    private const string SPIKED_PIGGY_BANK_IMAGE_PATH = "images/spiked-piggy-bank-towards-viewer.jpeg";
    private const string BLOODED_SPIKED_PIGGY_BANK_IMAGE_PATH = "images/smash-spiked-piggy-bank-on-head.jpeg";
    private const string SMASHED_PIGGY_BANK_IMAGE_PATH = "images/smash-piggy-bank-on-head.jpeg";


    private bool _isGameStarted = false;
    private bool _isRegularPiggyBank = true;
    private bool _hasPlayerShakenThisRound;
    private bool _hasOpponentShakenThisRound;
    private bool _hasPlayerActedThisTurn;
    private bool _hasOpponentActedThisTurn;
    private bool _hasOpponentRunOutOfGoodOptions;
    private bool _isPlayersTurn =true;
    private bool _isOpponentsTurn=false;
    private bool _isPlayerCoinDisabled;
    private bool _isOpponentCoinDisabled;
    private bool _isPlayerShakeDisabled;
    private bool _isOpponentShakeDisabled;
    private bool _isPlayerSpecialDisabled;
    private bool _isOpponentSpecialDisabled;
    private bool _isPlayerEndTurnDisabled;
    private bool _isOpponentEndTurnDisabled;
    private bool _isPlayerControlsDisabled;
    private int _piggyBankCapacity;
    private int _piggyBankCoinCount = 0;
    private int _playerHealthCount = 3;
    private int _opponentHealthCount = 3;
    private int _currentGameMaxHealth = 3;
    private int _playerPocketMoneyCount = 0;
    private int _opponentPocketMoneyCount;
    private int _playerPlayedCoinsCount;
    private int _opponentPlayedCoinsCount;
    private int _playerPlayedSpecialCoinsCount;
    private int _opponentPlayedSpecialCoinsCount;
    private int _currentDialogIndex;
    private int _gamesWon = 0;
    private bool _isNewRoundStarting = false;
    private int _higherDisparity;
    private int _lowerDisparity;
    private int opponentPiggyBankCapacityGuessLow;
    private int opponentPiggyBankCapacityGuessHigh;
    private int _roundCount = 0;
    private string _imagePath = PIGGY_BANK_IMAGE_PATH;
    private List<(string line1, string line2)> _dialogList = new();
    private (string line1, string line2) _dialog = (
        "It's your turn. Insert up to 3 coins or shake the swine", 
        "Once you have done all you desire, you may end your turn" 
        );
    private List<SpecialCoins> _playerSpecialCoins = new();
    private List<SpecialCoins> _opponentSpecialCoins = new();
    private List<SpecialCoins> _specialCoinShopItems = new();
    private List<OpponentAction> _opponentsActionsThisTurn = new();
    private int PiggyBankLowerLimit() => _piggyBankCapacity - _lowerDisparity;
   private int PiggyBankHigherLimit() => _piggyBankCapacity - _higherDisparity;
    
    private void StartGameButtonPressed()
    {
        _isGameStarted = true;
        PrepareNewRound();
        DisableControls();
        IntroductionDialog();
        InvokeAsync(StateHasChanged);
    }

    public void PrepareNewRound()
    {
        
        _roundCount++;
        _hasOpponentShakenThisRound = false;
        _hasPlayerShakenThisRound = false;
        _isPlayersTurn = true;
        _isOpponentsTurn = false;
        _playerPlayedCoinsCount = 0;
        _opponentPlayedCoinsCount = 0;
        _piggyBankCoinCount = 0; //should happen before generating new capacity
        GenerateCapacityAndRange();
        InvokeAsync(StateHasChanged);
    }

    public void IntroductionDialog()
    {
        _dialogList.Add(("Greetings!","And welcome to the game"));
        _dialogList.Add(("Survive!","For as long as you can"));
        _dialogList.Add(("Above the swine, a range","The swine's limit is within that range"));
        _dialogList.Add(("Fill the swine","And its fortune shall be yours"));
        _dialogList.Add(("You may shake the swine once","To discover its contents"));
        _dialogList.Add(("Shake, or provide","You must choose one"));
    }

    public void ProgressDialogStream(){
        _dialogList.RemoveAt(0);
        if(_isOpponentsTurn)
        {
            performNextOpponentAction();
        }
        else if(_isPlayersTurn && !_dialogList.Any())
        {
            EnableControls();
        }
        else if(!_isOpponentsTurn && !_isPlayersTurn && _isNewRoundStarting)
        {
            EnableControls();
            _isPlayersTurn = true;
        }
    }



    private void GenerateCapacityAndRange()
{
    // Random number generator
    Random random = new Random();

    // Generate a random capacity between 3 and 20
    _piggyBankCapacity = random.Next(3, 21);

    // Determine the increment range based on games won
    int incrementMax;
    if (_gamesWon <= 10)
        incrementMax = 1;
    else if (_gamesWon <= 20)
        incrementMax = random.Next(1, 3); // Random between 1 and 2
    else if (_gamesWon <= 30)
        incrementMax = random.Next(1, 4); // Random between 1 and 3
    else if (_gamesWon <= 40)
        incrementMax = random.Next(1, 5); // Random between 1 and 4
    else
        incrementMax = random.Next(1, 6); // Random between 1 and 5

    // Reset disparities to 0
    _higherDisparity = 0;
    _lowerDisparity = 0;

    // Apply increments to disparities
    for (int i = 0; i < incrementMax; i++)
    {
        bool incrementHigherDisparity = true;

        // Boundary checks
        if (_piggyBankCapacity + _higherDisparity == 20)
            incrementHigherDisparity = false; // Force increment to lower disparity
        else if (_piggyBankCapacity - _lowerDisparity == 3)
            incrementHigherDisparity = true; // Force increment to higher disparity
        else
            incrementHigherDisparity = random.Next(0, 2) == 0; // 50/50 chance otherwise

        if (incrementHigherDisparity)
            _higherDisparity++;
        else
            _lowerDisparity++;
    }
}


    private void DisableControls() => _isPlayerControlsDisabled = true;
    private void EnableControls() => _isPlayerControlsDisabled = false;

    private void NewTurn() 
    {
        //In this condition, we are moving from the players turn to the OPPONENT'S TURN
        if(_isPlayersTurn)
        {
            _isOpponentsTurn = true;
            _isPlayersTurn = false;
            _opponentPlayedCoinsCount = 0;
            _hasPlayerActedThisTurn = true;
            DisableControls();
            RunOpponentTurn();
        }
        //In this condition, it is either the opponent's turn or nobody's turn so we are moving the PLAYER'S TURN
        else
        {
            _isOpponentsTurn = false;
            _isPlayersTurn = true;
            _playerPlayedCoinsCount = 0;
            _hasPlayerActedThisTurn = false;

            EnableControls();
        }
    }

private void RunOpponentTurn()
{
    Console.WriteLine("Opponent turn executing");
    //Calculate Opponent's win chance this turn
    int opponentWinChance = CalculateWinChance(out List<OpponentAction> offensiveActions);

    //Calculate Opponent's loss chance this turn
    int opponentLossChance = CalculateLossChance(out List<OpponentAction> defensiveActions);

    //If the win chance is higher or equal
        //perform offensive strategy
    //else
        //perform defensive strategy
    if (opponentWinChance >= opponentLossChance)
    {
        _opponentsActionsThisTurn = offensiveActions;
    }
    else
    {
        _opponentsActionsThisTurn = defensiveActions;
    }
    performNextOpponentAction();
}

private int CalculateWinChance(out List<OpponentAction> offensiveActions)
{

    offensiveActions = new List<OpponentAction>{OpponentAction.InsertCoin,OpponentAction.InsertCoin,OpponentAction.InsertCoin,OpponentAction.EndTurn};
    int projectedCoinsInBank = _piggyBankCoinCount;
    //work out the difference in the piggy bank capacity's range
    int capDiff = (_piggyBankCapacity+_higherDisparity)-_piggyBankCoinCount;
    //divide 100 by the cap diff +1. this will be the amount that the chance of winning will increase by each time you put in a coin to 
    //bring the current amount of coins in the piggy bank to a value withint the range
    int chanceIncrement = 100 / Math.Max(capDiff + 1, 1);
    int opponentWinChance = 0;
    //opponent has 3 coins to use. so do a for loop with i = 3
    for(int i = 0; i < 3 ; i++)
    {
        //add a coin
        projectedCoinsInBank++;
        //if the current coin count is within the range, increment the coin count
        if(projectedCoinsInBank >= (_piggyBankCapacity-_lowerDisparity) && projectedCoinsInBank <= (_piggyBankCapacity+_higherDisparity))
        {
            opponentWinChance += chanceIncrement;
        }
    }

    return opponentWinChance;
}

private int CalculateLossChance(out List<OpponentAction> defensiveActions)
{
    defensiveActions = new();
    int opponentLossChance = 100; // Start with the maximum possible chance
    List<OpponentAction> bestDefensiveActions = new();

    // Simulate all valid combinations of defensive actions
    // 2. Insert 0 to 3 coins, then end the turn
    for (int coinsToInsert = 0; coinsToInsert <= 3; coinsToInsert++)
    {
        List<OpponentAction> insertActions = new List<OpponentAction>();
        int simulatedBankCount = _piggyBankCoinCount;

        for (int i = 0; i < coinsToInsert; i++)
        {
            insertActions.Add(OpponentAction.InsertCoin);
            simulatedBankCount++;
        }

        insertActions.Add(OpponentAction.EndTurn);

        int playerWinChance = SimulatePlayerWinChance(simulatedBankCount, !_hasPlayerShakenThisRound);
        if (playerWinChance < opponentLossChance)
        {
            opponentLossChance = playerWinChance;
            bestDefensiveActions = insertActions;
        }
    }

    // 1. Shake and end the turn (if shaking is allowed) This should be done as a last resort
    if (!_hasOpponentShakenThisRound)
    {
        List<OpponentAction> shakeActions = new List<OpponentAction>
        {
            OpponentAction.Shake,
            OpponentAction.EndTurn
        };

        int playerWinChance = SimulatePlayerWinChance(_piggyBankCoinCount, !_hasPlayerShakenThisRound);
        if (playerWinChance < opponentLossChance)
        {
            opponentLossChance = playerWinChance;
            bestDefensiveActions = shakeActions;
        }
    }
    
    //DEBUG: Show current opponent's actions before going random
    foreach(var action in bestDefensiveActions)
    {
        Console.WriteLine(action.ToString());
    }


    // Assign the best defensive actions
    if (bestDefensiveActions != null)
        defensiveActions = bestDefensiveActions;

    if (defensiveActions.Count() == 1 && defensiveActions.Contains(OpponentAction.EndTurn))
        {
            defensiveActions = new();
            // Random number generator
            Random random = new Random();

            for(int i=0; i< random.Next(1, 4); i++)
            {
                defensiveActions.Add(OpponentAction.InsertCoin);
            }
            defensiveActions.Add(OpponentAction.EndTurn);
        }

    return opponentLossChance;
}


private int SimulatePlayerWinChance(int simulatedBankCount, bool playerCanShake)
{
    int playerWinChance = 0;

    // Calculate the player's chances of winning based on the simulated state
    int capDiff = (_piggyBankCapacity + _higherDisparity) - simulatedBankCount;
    int chanceIncrement = 100 / Math.Max(capDiff + 1, 1);


    // Player can use up to 3 coins
    for (int i = 0; i < 3; i++)
    {
        simulatedBankCount++;
        if (simulatedBankCount >= (_piggyBankCapacity - _lowerDisparity) && simulatedBankCount <= (_piggyBankCapacity + _higherDisparity))
        {
            playerWinChance += chanceIncrement;
        }
    }

    // Adjust win chance based on whether the player can shake
    if (playerCanShake)
    {
        playerWinChance = Math.Min(playerWinChance + 10, 100); // Arbitrary bonus for shaking
    }

    return playerWinChance;
}

private void performNextOpponentAction()
{
    if(_piggyBankCoinCount == _piggyBankCapacity)
        {
            CrackPiggyBank();
        }
            else
            {
                switch(_opponentsActionsThisTurn[0])
                {
                    case OpponentAction.InsertCoin:
                        OpponentDropCoinAction();
                        break;

                    case OpponentAction.Shake:
                        OpponentShakeAction();
                        break;

                    case OpponentAction.EndTurn:
                        OpponentEndTurnAction();
                        break;
                }
                _opponentsActionsThisTurn.RemoveAt(0);
            }
        
}




    private void OpponentShakeAction()
    {
        _hasOpponentActedThisTurn = true;
        _hasOpponentShakenThisRound = true;
        //add equalizer to the opponent's preceived limit once expanding coins are added
        _dialogList.Add(("The opponent shook the swine","And now knows how many coins it holds"));
    }

    private void OpponentDropCoinAction()
    {
        _opponentPlayedCoinsCount++;
        _piggyBankCoinCount++;
        _hasOpponentActedThisTurn = true;
        _dialogList.Add(("The opponent inserts a coin into the swine",$"They have inserted {(_opponentPlayedCoinsCount + _opponentPlayedSpecialCoinsCount)} coins this turn"));
    }

    private void OpponentEndTurnAction() 
    { 
        NewTurn();
        _dialog = ("The opponent ends their turn","Please select an action");
    }



    private void PlayerDropCoinAction() 
    { 
        //Put the reverse of the disabled condition here too as crafty players might try to reenable the button using dev tools
        if(!(_isPlayerCoinDisabled || _isPlayerControlsDisabled || (_playerPlayedCoinsCount == MAX_COINS_PLAYABLE)))
        {
        //put the coin in
            if(_isPlayersTurn)
            {
                _playerPlayedCoinsCount++;
                _piggyBankCoinCount++;
                _hasPlayerActedThisTurn = true;
            }
            //if it has hit the limit. crack the piggy bank
            if(_piggyBankCoinCount == _piggyBankCapacity)
            {
                CrackPiggyBank();
            }
            else
            {
                _dialog = (
                    "You insert a coin into the swine", 
                    $"You have inserted {(_playerPlayedCoinsCount + _playerPlayedSpecialCoinsCount)} coins this turn" 
                );
            }
        }    
    }

    public void CrackPiggyBank()
    {

        DisableControls();
        if(_isPlayersTurn)
        {
            _isPlayersTurn = false;
            _isOpponentsTurn = false;
            if(_isRegularPiggyBank)
            {
                _dialogList.Add(("You have filled the swine",$"It is smashed on your head and all {(_piggyBankCoinCount)} coins pour out. You collect them"));
                _playerPocketMoneyCount += _piggyBankCoinCount;
                _piggyBankCoinCount = 0;
                
                StartShop();
            }
            else
            {
                _playerHealthCount--;
                if(_playerHealthCount <= 0)
                {
                    StartDefeat();
                }
                else
                {
                    StartShop();
                }
                
            }
            
                
        }

        if(_isOpponentsTurn)
        {
            _isPlayersTurn = false;
            _isOpponentsTurn = false;
            if(_isRegularPiggyBank)
            {
                _dialogList.Add(("The opponent has filled the swine",$"It is smashed on their head and all {(_piggyBankCoinCount)} coins pour out. They collect them"));
                _opponentPocketMoneyCount += _piggyBankCoinCount;
                _piggyBankCoinCount = 0;
                StartShop();
            }
            else
            {
                _dialogList.Add(("The opponent has filled the swine",$"It is smashed on their head. You hear the sound of metal colliding with bone. The swine doesn't crack"));
                _opponentHealthCount--;
                if(_opponentHealthCount <= 0)
                {
                    StartVictory();
                }
                else
                {
                    StartShop();
                }
            } 
        }     
    }

    public void StartDefeat()
    {
        //Display game over, the amount of games the player has won, and disable all controls
        _dialog = (
                    "The spiked piggy bank strikes one last time, its unyielding surface crushing hope along with bone", 
                    "As you draw your final breath, the coins within remain untouched, forever out of reach. GAME OVER" 
                );
        _isPlayerControlsDisabled = true;
    }

    public void StartVictory()
    {

    }

    public void StartShop()
    {
        //add shop logic. for now, a new round starts
        _dialog = ("A new round has begun", "Select an action");
        _isNewRoundStarting = true;
        PrepareNewRound();
        
    }

    private void PlayerShakeAction() 
    {
        //Put the reverse of the disabled condition here too as crafty players might try to reenable the button using dev tools
        if(!(_isPlayerShakeDisabled || _hasPlayerShakenThisRound || _isPlayerControlsDisabled)){
            
            _hasPlayerShakenThisRound = true;
            _hasPlayerActedThisTurn = true;
            _dialog = (
            "You Shake the swine", 
            $"Hmm... Sounds like it has {_piggyBankCoinCount} coins in it" 
            );
        }
    }
    private void SpecialAction() 
    { 
        //Put the reverse of the disabled condition here too as crafty players might try to reenable the button using dev tools
        if(!(_isPlayerSpecialDisabled || !_playerSpecialCoins.Any() || _isPlayerControlsDisabled))
        {
            
        }
        
    }
    private void EndTurnAction() 
    { 
        //Put the reverse of the disabled condition here too as crafty players might try to reenable the button using dev tools
        if(!(_isPlayerEndTurnDisabled || !_hasPlayerActedThisTurn || _isPlayerControlsDisabled ))
        {
            NewTurn();
        }
        
    }
}
